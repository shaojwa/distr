可串行化是事务的隔离级别，之所以需要事务的隔离级别，是因为事务需要并发，事务的并发，可以发生在多个客户端上，也可能出现在一个客户端上。
只要有多个事务发生，不管这些事务是由一个客户端发起，还是多个客户端发起，都存在并发的问题。

那么怎么来定义这个并发是否合理呢？一个事务，之所以需要隔离，那是因为有修改，对于一个事务来说，对一个值的修改，是某一刻发生的，但是这一刻到底发生在事务的什么时候，
并不知道，而且也无法知道，那么我们怎么知道修改发生了？

那就依赖读取，如果某个时候去读取一个值，如果读到的值是修改的，那么就可以断定，在这个时间节点前，这个值肯定修改过。

好，现在在多条时间线上，有多个事务，我们怎么来确认，结果是满足串行化的呢？即结果在可串行化的要求下合理呢？
那么，我们可以这么定义，只要能找到一种满足条件的事务的排序，最终结果能得到实际的结果，那就可以说这个结果再“可串行化”的条件下，是正确的。

那现在的问题变成，怎么来设定这些事务的条件呢？即在这些条件都满足的情况下，可能会有很多中事务的排序，只要有一种能产生预期的结果就行。
那我们现在来设定这些条件。我们首先会想到一点：

（1）在可能的串行排序中，原本在同一个客户端上的事务，排序先后顺序需要保持一致。
（2）在一个事务完成前，不能被别的事务读到新的值。如果读到了新的值，那么这个事务一定要排在旧值事务之后。
（3）如果一个事务读到的值，不依赖某个事务的修改，那么，这两个事务的顺序可以任意排列。

这是一种从数学上的定义？可串行化。这样是否就足够了呢？我不清楚。我需要再想一下。
